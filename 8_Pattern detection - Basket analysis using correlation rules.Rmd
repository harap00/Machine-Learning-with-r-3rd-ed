---
title: "8_Pattern detection - Basket analysis using correlation rules"
editor_options: 
  markdown: 
    wrap: 72
---

# 第８章 パターン検出 ―相関ルールを使ったバスケット分析

　現在では、バーコードスキャナー、在庫データベース、オンラインショッピングカートにより、
機械学習による購入パターンの学習に利用できるトランザクションデータが生成されている。
この手法はスーパーマーケットのでたーによく適用されることから、
一般に**マーケットバスケット解析** (market basket analysis)
または単に**バスケット分析** と呼ばれている。\
　バスケット解析は購入データから生まれた手法だが、他の状況でも役立つ。貴方が抱えて
一般的には、次のようなタスクに利用できる。

-   単純な性能指標を使って大規模なデータベースから相関を見つけ出す
-   トランザクションデータの特異性を理解する
-   意思決定に活かせる有益なパターンの特定方法を突き止める

　バスケット分析の目標は、意思決定に活かせるパターンを発見することである。したがって、
貴方の仕事が小売チェーンとはなんの関係もなくても、この手法を実際に適用する仮定で、ど
のように対応すればよいかが明らかになるはずだ。

## 8.1 相関ルールを理解する

　バスケット分析の構成要素は、特定の取引(トランザクション)に出現する商品（アイテム）である。
１つ以上の商品からなるグループを波かっこで囲み、それらがセットであることを示すか、あるいは
もっと具体的に、一定の頻度でデータに出現する**アイテムセット**(itemset)\*\*で
あることを示す。トランザクションはアイテムセットに基づいて指定する。一般的なスーパーで
見られるトランザクションは次のようなものだ。

$$｛パン、ピーナッツバター、ゼリー｝$$

　バスケット分析の結果は、一連の**相関ルール**(association
rule)である。これらの相関ルールは、アイテムセット内のアイテム間の関係から見つかったパターンを表す。相関ルールは常にアイテムセットのサブセットで構成され、ルールの左辺(LHS)のアイテムセットがルールの右辺(RHS)のアイテムセットに関連していることを表す。LHSは、このルールを呼び出すために満たさなければならない条件であり、RHSは、その条件が満たされたときに想定される結果である。先のトランザクションから特定されたルールは、次のように表現されるかもしれない。

$$
｛ピーナツバター、ゼリー｝→｛パン｝
$$

　言葉で説明すると、kの相関ルールは「ピーナツバターとゼリーが一緒に購入されたら、パンも購入される可能性が高い」ことを表している。言い換えると、「ピーナツバターとゼリーはパンを含意している」。\
　相関ルールは小売業のトランザアクションデータベースに基づいて開発されたものなので、予測に使われるのではなく、大規模なデータベースの教師なし学習による知識の発見に使われる。したがって、ここまで取り上げてきた分類アルゴリズムや仕打ち予測アルゴリズムとは勝手が異なる。とはいえ、相関ルール学習器はこれまでに取り扱った分類ルール学習器と密接な関係にあり、多くの特徴を共有している。\
　相関ルール学習は教師なし学習であるため、アルゴリズムを訓練する必要はなく、データを事前にラベルづけする必要もない。興味深い関係が見つかることを期待して、プログラムをデータセットに放り込むだけである。当然ながら、定性的な有用性の評価（通常は何らかの目視検査）を別にすれば、相関ルール学習器の性能を客観的に計測するのが容易ではないという欠点がある。\
　相関ルールが最も良く使われるのはバスケット分析だが、相関ルールは様々な種類のデータからパターンを見つけ出したい場合にも役立つ。たとえば、次のような用途が考えられる。

-   がん細胞データに頻繁に出現する興味具解DNAパターンとタンパク質配列の検索
-   クレジットカードや医療保険の不正利用でよく見られるこうにゅうぱたーんのや医療請求パターンの特定
-   携帯電話-サービスの解約やケーブルテレビプランのアップグレードの前触れとなる顧客行動の特定

　相関ルールは膨大な数の要素の中から興味深い結びつきを見つけ出すために分析される。人間はそのような結びつきを直感的に見抜くことができるが、相関ルール学習器が数分あるいは数秒足らずで実行できることを実現するには、専門家レベルの知識や多くの経験が必要になることが多い。それに加えて、データセットが単に大規模で複雑すぎるために、人間にとって干し草の山の中から１本の針を見つけ出すのに等しいこともある。

### 8.1.1 相関ルール学修のためのアプリオリアルゴリズム

　大規模なトランザクションデータベースは人間にとって難題だが、機械にとっても難題である。トランザクションデータベースの大きさには、トランザクションの個数と、記録されているアイテムまたは特徴量の個数うという２つの意味合いがある。問題は、アイテムセットの個数が増えると、特徴量の個数が幾何級数的に増えることである。アイテムセットに出現するかもしれないアイテムの個数が$k$であるとすれば、相関ルールに含まれるかもしれないアイテムセットの個数は$k^2$になる。たった100種類の商品を販売しているだけでも評価しなければならないアイテムセットの個数は$2^{100}=1.27e+30$になる。不可能に思える数字である。\
　よりスマートな相関ルール学修器は、これらのアイテムセットを１つずつ評価するのではなく、「アイテムの組み合わせとして考えられるものの多くは（皆無ではないにせよ）実際にはほとんど見つからない」という事実を利用する。たとえば、ある店舗で自動車関連商品と女性の化粧品が販売されていたとしても｛エンジンオイル、リップスティック｝というアイテムセットが見つかる可能性は途方もなく低い。このような滅多に見つからない（そしておそらくそれほど重要ではない）組み合わせを無視すれば、ルールの検索範囲をより扱いやすい大きさに絞り込めるはずだ。\
　アイテムセットの検索数を減らすためのヒューリスティックなアルゴリズムの特定には、膨大な労力が注ぎ込まれてきた。おそらく、大規模なデータベースでルールを効率よく検索するために最も広く使われているアプローチは、**アプリオリ**(Apriori)
だろう。1994年に発表したアプリオリアルゴリズムは、それ以来、相関ルール学習の代名詞となっている。このアルゴリズムは頻繁に出現するアイテムセットの性質に関する単純な先見的知識(a
priori)を利用する。アプリオリという名前はそこから来ている。
　詳しい説明に進む前に注意しておきたいのは、すべての学習アルゴリズムと同様に、このアルゴリズムにも長所と短所があることだ。

+----------------------------------+----------------------------------+
| 長所                             | 短所                             |
+==================================+==================================+
| ・大量のトラ ン ザ ク シ         | ・小規模な デ ー タ セ           |
| ョンデータに対処できる           | ットではあまり役にたたない       |
|                                  |                                  |
| ・ 理 解 し                      | ・本物の知見と 常 識 を 区       |
| やすいルールが得られる           | 別するための作業が発生する       |
|                                  |                                  |
| ・データマイニ ン グ だ け       | ・ランダムなパターンに惑 わ さ   |
| ではなくデータベースか ら の 意  | れ て 誤った結論を導くことがある |
| 外 な知識の発見にも役立つ        |                                  |
+----------------------------------+----------------------------------+

　すでに述べたように、アプリオリアルゴリズムは相関ルールの検索空間を狭めるためのガイドラインとして単純な先験的知識を求める―――頻繁に出現するアイテムセットのサブセットはすべて頻繁に出現するはずである。このユーリスティクスを**アプリオリ性**(Apriori
property)と呼ぶ。このするどう観測を利用すれば、
ルールの検索数を劇的に減らすことができる。たとえば、｛エンジンオイル、リップスティック｝が頻繁に出現するのは、｛エンジンオイル｝と｛リップスティック｝の両方が頻繁に出現する場合だけである。したがって、エンジンオイルとリップスティックのどちらかが頻繁に出現しない場合は、これらの商品を含んでいるすべてのアイテムセットを、最初から、検索の対象から外すことができる。\

　この原則を実現的な状況でどのように応用できるかを調べるために、単純なトランザクションデータベースについて考えてみよう。下表は架空の病院のギフトショップで記録された５つの完了済みトランザクションを示している。

| トラン ザクションID |                購入された商品                |
|:-------------------:|:--------------------------------------------:|
|         １          |     ｛花束、メッセージカード、ジュース｝     |
|         ２          | ｛クマのぬいぐるみ、花束、風船、チョコバー｝ |
|         ３          |    ｛メッセージカード、チョコバー、花束｝    |
|         ４          |     ｛クマのぬいぐるみ、風船、ジュース｝     |
|         ５          |     ｛花束、メッセージカード、ジュース｝     |

: 図８-１：架空の病院のギフトショップで記録された５つのトランザクションを表すアイテムセット

　これらの販売履歴から、典型的な購入パターンが２つ浮かび上がる。闘病中の友人や家族のお見舞いに来た人はメッセージカードと花束を購入する傾向があるのに対し、出産した女性のお見舞いに来た人はクマのぬいぐるみと風船を購入する傾向にある。このようなパターンが見て取れるのは、わたしたちの興味を引くほど頻繁に現れるからだ。ちょっとした論理と同じ状況での経験を働かせるだけで、このルールの説明がつく。\
　同様に、アプリオリアルゴリズムは、より大規模なトランザクションデータベースから相関ルールを見つけ出すために、アイテムセットの「興味度」をどのようにけいさんするのか、そして学習するルールの個数を減らすために興味度をとアプリオリ性をどのように組み合わせるのかを明らかにする。

### 8.1.2 興味度を計測する：指示度と確信度

　相関ルールが興味深いと見なされるかどうかは、指示度と確信度の２つの統計学的指標よって決まる。これらの指標ごとに最小値（閾値）を設定したうえでアプリオリの原則を適用すれば、ルールの個数を簡単に減らすことができる。おそらく、自明なルールや常識的なルールしか見つからないレベルまで減らすこともできるだろう。このため、これらの条件に従って除外するルールの種類についてよく理解しておくことが重要となる。\
　アイテムセットやルールの**指示度** (support)
は、それらがどれくらいの頻度でデータに出現するのかを表す。たとえば、病院のギフトショップの｛メッセージカード、花束｝というアイテムセットの指示度は、$3/5=0.6$である。同時に、｛メッセージカード｝→｛花束｝の支持率も0.6である。指示度はどのアイテムセットでも、あるいは1つのアイテムでも計算できる。たとえば、｛チョコバー｝の指示度が$2/5=0.4$であるのは、チョコバーが購入履歴の40%に達しているからだ。アイテムセット$X$の支持率は次のように定義できる。

$$
{\rm support}(X)=\frac{{\rm count}(X)}{N}
$$
　ここで、$N$はデータベース内のトランザクションの個数であり、$count(X)$はアイテムセット$X$を含んでいるトランザクションの個数である。\
　ルールの**確信度**(confidence)は、予測性能（正解率）を表す。確信度は$X$と$Y$を両方とも含んでいるアイテムセットの指示度を、$X$だけを含んでいるアイテムセットの支持率で割ったものとして定義される。

$$
{\rm confidence}(X→Y)=\frac{{\rm support}(X,Y)}{{\rm support}(X)}
$$

　基本的には、アイテムまたはアイテムセット$X$の出現がアイテムまたはアイテムセット$Y$の出現につながっているトランザクションの割合を表すのが確信度である。$X$が$Y$をもたらす確信度と、$Y$が$X$をもたらす確信度が同じではないことに注意しよう。たとえば｛花束｝→｛メッセージカード｝の確信度は$0.6/0.8=0.75$だが、｛メッセージカード｝→｛花束｝の確信度は$0.6/0.6=1.0$であるつまり、花束を購入する時は75%の確率でメッセージカードも購入するが、メッセージカードを購入する時は100%の確率で花束を購入する。ギフトショップを運営するにあたって、この情報は非常に参考になるかもしれない。

> 　指示度、確信度、ベイズの定理の間に類似性があることに、気づいているかもしれない。実際には、${\rm support}(A,B)$は$P(A \cap B)$と同じであり、${\rm confidence}(A→B)$は$P(B|A)$と同じである。違いはコンテキストだけである。

　{メッセージカード｝→｛花束｝のようなルールは、支持度と確信度の両方が高いことから、**強いルール**(strong
rule)と呼ばれる。より強いルールを見つけ出す方法の１つは、ギフトショップの商品の組み合わせを１つ残らず調べて、支持度と確信度を計算し、特定の興味度に達しているルールだけを返すことだろう。しかし、すでに述べたように、データセットがよほど小さいならともかく、この戦略はたいてい現実的ではない。\
　アプリオリアルゴリズムは、最低レベルのしじどをと確信度をアプリオリの原則と組み合わせることで、ルールをより扱いやすい数に絞り込む。

### 8.1.3 アプリオリ減速を使ってルールセットを構築する

　アプリオリの原則によれば、「頻繁に出現するアイテムセットのサブセットはすべて頻繁に出現するはずである」。つまり{$A,B$}が頻繁に出現するなら、{$A$}と{$B$}の両方が頻繁に出現するはずである。また、支持度が定義上、アイテムセットがデータの中にどのくらい頻繁に出現するのかを表す指標であることも思い出そう。したがって、支持度の望ましい閾値を{$A$}が満たさないことがわかっているとしたら、{$A,B$}といった{$A$}を含んでいるアイテムセットを考慮すべき理由はまったくない。そのようなアイテムセットが頻繁に出現することはありえないからだ。\
　アプリオリアルゴリズムは、このロジックを使って、相関ルールの候補を実際に評価する前にふるい落とす。したがって、相関ルールを作成するプロセスは次の２段階に分かれている。

1.  支持度の最小値（閾値）を満たしているアイテムセットをすべて洗い出す。
2.  これらのアイテムセットのうち、確信度の最小値（閾値）を満たしているものを使ってルールを作成する。

　第１段階は複数のイテレーションで構成され、イテレーションのたびにアイテムセットを徐々に大きくしながら支持度を評価する。たとえば、イテレーション１では、
　１アイテムのアイテムセットの集合を評価し、イテレーション２では、２アイテムのアイテムセットの集合を評価する。イテレーション$i$の結果は、$i$アイテムのアイテムセットの集合であり、それらすべてのアイテムセットが支持度の最小値（閾値）を見達している。\
　イテレーション$i$の結果であるアイテムセットをすべて組み合わせたものが、イテレーション$i+1$で評価するアイテムセットの候補となる。しかし、アプリオリ減速を用いれば、次のイテレーションがハイジある前に候補の一部を除外できる。イテレーション１では{$A$}、{$B$}、{$C$}が頻繁に出現していて、{$D$}が頻繁に出現していないとしたら、イテレーション２の候補は、アイテムセットはたった３つである。{$D$}を含んでいるアイテムセットを事前に除外していなければ、アイテムセットを６つも評価していたところだった。\
　同じ要領で、イテレーション２では{$A$,$B$}と{$B$,$C$}が頻繁に出現していて、{$A$,$C$}が頻繁に出現していないとしよう。イテレーション３では本来なら{$A$,$B$,$C$}の支持度を評価するところだが、この評価をする必要はない。なぜだろう。{$A$,$C$}は頻繁に出現していないため、アプリオリの原則に照らすと{$A$,$B$,$C$}は頻繁に出現するとは言えないからだ。したがって、イテレーション３では新しいアイテムセットが生成されず、アルゴリズムはそこで終了になる。

+----------------+----------------+----------------+----------------+
| イ テ レ ー シ | 評 価 が 必 要 | 頻 出 す る\   | 頻 出 し な    |
| ョ ン          |                | ア イ テ ム セ | い\            |
|                |                | ッ ト          | ア イ テ ム セ |
|                |                |                | ッ ト          |
+:==============:+================+================+================+
| 1              | { A }, { B },  | { A }, { B },  | { D}           |
|                | { C }, { D}    | { C}           |                |
+----------------+----------------+----------------+----------------+
| 2              | { A, B }, { A, | { A, B }, { B, | { A, C}        |
|                | C }, { B, C }\ | C}             |                |
|                | ~~{ A, D }, {  |                |                |
|                | B, D }, { C, D |                |                |
|                | }~~            |                |                |
+----------------+----------------+----------------+----------------+
| 3              | ~~{ A, B, C    |                |                |
|                | }~~            |                |                |
+----------------+----------------+----------------+----------------+
| ４             | ~~{ A, B, C, D |                |                |
|                | }~~            |                |                |
+----------------+----------------+----------------+----------------+

: 図8-2：アプリオリアルゴリズムが評価する必要があるのは12候補の7つだけ

　この時点で、アプリオリアルゴリズムの第２段階が始まることが考えられる。頻繁に出現するアイテムセットの集合があるとすれば、考えラエルすべてのサブセットから相関ルールが生成される。たとえば、{*A,
B*} から
{*A*}→{*B*}と{*B*}→{*A*}の候補ルールが生成される。これらの候補は確信度の最小値（閾値）に治して評価され、確信度を満たしていない候補はすべて除外される。

## 8.2 例：相関ルールを使って頻繁に購入される商品を特定する

　このチュートリアルでは、食品店のトランザクションデータでバスケット分析を行う。ここで説明する手法は、さまざまな種類の問題に応用可能である。たとえば、映画のレコメンデーション、出会い系サイト、医薬品の危険な飲み合わせの発見などが考えられる。相関ルールは膨大な数になる可能性があるが、ここではアプリオリアルゴリズムがどのようにしてそれらのルールを効率よく評価するのかを確認する。

### ステップ１：データを収集する

　このバスケット分析では、現実の食料品店で収集された1ヶ月分の購入データを利用する。このデータに含まれているトランザクションは合計9,825件であり、１日あたり約327件である（営業時間を12時間とすれば、1時間あたり約30件である）。この数からすると、それほど大きな店ではないが、特に小さくもない。\
　一般的な食料品店は様々な商品を販売している。５つの銘柄の牛乳、１２種類の洗濯用洗剤、３つ銘柄のコーヒーが並んでいるかもしれない。この店舗あh大きくも小さくもないため、特定のブランドの牛乳や洗剤に適用されるルールの特定については考えないことにする。このため、ブランド名は購入データから完全に削除されている。このようにして、商品を169種類という扱いやすい数に絞り込み、鶏肉、冷凍食品、マーガリン、炭酸飲料のような大雑把なカテゴリを使っている。

> 「顧客がピーナッツバターといっしょに購入するのはグレープゼリーかストロベリーゼリーか」のような、より限定的な相関ルールを特定したい場合は、膨大な量のトランザクションデータが必要になるだろう。大規模なチェーン店では、特定のブランド、色、味の商品の間から相関を見つけ出すために、数百万件から数千万件のtランザクションを含んだデータベースを使っている。

　どのようなシュリの商品が失書に購入されるか見当がつくだろうか。ワインとチーズはよくある組み合わせだろうか。パンとバター、紅茶とハチミツはどうだろうか。このデータを調べてそれらの推測が当たっているかどうか見てみよう。

### ステップ２：データの調査と前処理

　トランザクションデータは、これまで使ってきたものとは少し異なるフォーマットで格納される。これまでの分析のほとんどは行列形式のデータを利用するもので、行列の行がインスタンス、列が特徴量を表していた。行列フォーマットとでは、すべての因子タンスが全く同じ特徴量で構成っされていなければならない。\
　これに対し、トランザクションデータはもっと自由である。これまでと同様に、出たの業はそれぞれ１つのインスタンス（この場合はトランザクション）を表す。しかし、各インスタンスは決まった数の特徴量で構成されるのではなく、１つ以上のアイテムをコンマで区切ったリストで構成される。基本的に、特徴量はインスタンスごとに異なる可能性がある。

　groceries.csvファイルの最初の５行は次のとおりである。

```         
citrus fruit,semi-finished bread,margarine,ready soups
tropical fruit,yogurt,coffee
whole milk
pip fruit,yogurt,cream cheese,meat spreads
other vegetables,whole milk,condensed milk,long life bakery product
```

　これらの行は、食品店の５つの取引データ（トランザクション）を表している。１つ目のトランザクションには、citrus
fruit, semi-finished bread, margarine, ready soups
の４つのアイテムが含まれている。これに対し、３つ目のトランザクションには、１つの商品(whole
milk)しか含まれていない。\
　これまでの分析と同じように、read.csv関数を使ってデータを読み込もうとした場合、データは次のように読み込まれる。

```{r}
if(! require(tidyverse)){
    install.packages('tidyverse', quiet = TRUE)
}
library(tidyverse)
```

```{r}
read.csv('https://raw.githubusercontent.com/dataspelunking/MLwR/master/Machine%20Learning%20with%20R%20(3rd%20Ed.)/Chapter08/groceries.csv', stringsAsFactors = FALSE, header = FALSE) %>% head(5)
```

　Rが４つの変数を作成したのは、最初の行にちょうど４つ値がコンマ区切りで含まれていたからだ。しかし、トランザクションデータに含まれているアイテムは４つだけとは限らない。４列の設計では、そのようなトランザクションが複数の行に分割されることになってしまう。また記録されている順序により別の特徴量として取り扱われてしまう。

#### データの前処理：トランザクションデータから疎行列を作成する

　この問題を解決するために、**疎行列**(sparse
matrix)と呼ばれるデータ構造を利用する。疎行列の各業は、先ほどのデータセットと同じように、１つのトランザクションを表す。しかし、この疎行列には、誰かの買い物かごに入っている可能性がある商品ごとに列（特徴量）が１つ存在する。この食料品店のでーたには169種類の商品が存在するため、この疎行列は169個の列で構成されることになる。\
　これまでのほとんどの分析では、このようなデータをデータフレームに格納していた。なぜそうしないのだろうか。従来のデータ構造は、新しいトランザクションやアイテムが追加されるとすぐに大きくなってしまい、利用可能なメモリに収まらなくなるからだ。ここで使っているトランザクションデータセットは比較的小さなものだが、それでも行列に含まれるセルの数は170万近くになり、その殆どに0が含まれている（0ではない値がほとんどないことが、「疎」行列と呼ばれる所以である）。\
　これらの０がすべて格納されていても意味がないため、疎行列の場合、行列全体が実際にメモリに格納されることはなく、アイテムが含まれているセルだけが格納される。このようにすると、同じサイズの行列やデータフレームよりもメモリを効率よく利用できるようになる。\
　タランザクションデータから疎行列を生成したい場合は、arules(assciation
rules)パッケージの機能を利用できる。

```{r}
# パッケージの読み込み

if(! require(arules)){
  install.packages('arules', quiet = TRUE)
}
library(arules)
```

```{r}
# トランザクションの読み込み

groceries <- read.transactions('https://raw.githubusercontent.com/dataspelunking/MLwR/master/Machine%20Learning%20with%20R%20(3rd%20Ed.)/Chapter08/groceries.csv', sep = ',')
```

　groceries行列の基本情報を確認するには、summary関数を使う。

```{r}
# データの基本情報
summary(groceries)
```

　出力の最初のブロックを見てみると、この疎行列の基本情報を提供する。9835rowsの行はトランザクションの個数を表しており、169columnsの行は誰かの買い物かごに入っていたかもしれない商品が169種類あることを示している。この疎行列の各セルは、その商品がそのトランザクションで購入された場合は１になり、購入されなかった場合は0になる。\
　0.0269146(2.6%)は**密度**(density)であり、0ではないセルの割合を表す。この行列には9,835*169=1,662,115個のセルが存在するため、食料品店の
30日間の営業で1,662,115*0.02609146=43,367個の商品が購入された計算になる（なお、同じ商品が複数購入されている可能性については無視している）。それに加えて、１つのトランザクションに平均して43,367/9,853=4.409種類の商品が含まれていることもわかる。もちろん、出力の下の方を見ればトランザクションあたりの商品の平均数がすでに表示されていることがわかる。\
　summary関数の出力の次のブロックには、トランザクションデータに最もよく出現しているアイテムが列挙されている。2,513/9,853=0.2555なので、whole
milkはトランザクションの25.6%に出現していると判断できる。whole
milk以外によく出現している商品として、other vegetables、
rolls/buns、soda、 yogurtが出力されている。\
　最後に、トランザクションのサイズに関する統計量が出力されている。品目数が１つだけのトランザクションが合計で2,159件ある一方で、品目数が32のトランザクションが1件存在する。その後、四分位が表示されており、このなかに平均値表示されている。

　arulesパッケージには、トランザクションデータを分析するのに役立つ機能が含まれている。疎行列の内容を確認したい場合は、inspect関数にRのベクトル演算子を組み合わせる。最初の５トランザクションを表示するコマンドは次のようになる。

```{r}
inspect(groceries[1:5])
```

　これらのトランザクションは元のCSVファイルを調べたときの内容と一致している。特定の商品（データの列）を調べたい場合は、[row,
column]形式の行列表記を使う。この表記をitemFrequency関数で使うと、特定の商品を含んでいるトランザクションの割合を確認できる。たとえば、トランザクションデータの細書のつの商品に対する指示度を表示するには次のようにする。

```{r}
# 特定商品を含んでいるトランザクションの割合（１から３列目までの商品）
itemFrequency(groceries[, 1:3])
```

#### アイテムの支持度を可視化する：アイテム頻度プロット

　これらの統計量の可視化にはitemFrequencyPlot関数を使う。この関数は、特定のアイテムを含んでいるトランザクションの割合を棒グラフに表す。トランザクションデータは大量のアイテムを含んでいるため、多くの場合は、プロットするアイテムの数をせいげんしてグラフを読みやすくする必要があるだろう。\
　トランザクションに一定の割合で出現するアイテムを表示するには、itemFrequencyPlot関数を呼び出すときにsupportパラメータを指定する。

```{r}
# support 0.1% 以上のアイテム

itemFrequencyPlot(groceries, support = 0.1)
```

　プロットするアイテムの個数を制限したい場合は、itemFrequencyPlot関数を呼び出すときにtopNパラメータを指定する。

```{r}
# 上位20商品をプロット＃＃＃

itemFrequencyPlot(groceries, topN = 20)
```

###　トランザクションデータを可視化する：疎行列のプロット

　特定のアイテムを調べることに加えて、疎行列全体を俯瞰的に捉えることも可能である。これには、
image関数を使う。もちろん、行列全体が非常に大きいため、通常は行列全体のサブセットを表示するのが懸命である。
疎行列の最初の５件のトランザクションを表示するコマンドは次のようになる。

```{r}
image(groceries[1:5])
```

　このコマンドを実行すると、５行169列の行列が表示される。この図は、ここで要求している５件のトランザクションと169種類の商品を表している。トランザクション（行）に置いて商品（列）が購入されていることを表すセルは黒く塗りつぶされている。\
　この図は小さいので少し見づらいかもしれないが、１行目、４行目、５行目にそれぞれ塗りつぶされたセルが４つあるため、
１件目、４件目、５件目のトランザクションにそれぞれ４つの商品が含まれていることがわかる。
また、図の右側を見ると、３行目と５行目、および２行目と４行目に共通の商品があることもわかる。\
　このような可視化は、トランザクションデータを調べるのに役立つ可能性がある。
まず、データの潜在的な問題を見抜くのに役立つかもしれない。
上から下まで塗りつぶされている列があるとしたら、どのトランザクションでも購入されている商品を表している可能性があるが、
小売店の名前やID番号がトランザクションデータセットに誤って入力されているという問題を示していることも考えられる。\
　さらに、データが興味具解k方法でソートされている場合は特にそうだが、疎行列の図に現れているパターンが、
トランザクションやアイテムの興味深い部分を明らかにするのに役立つこともある。
たとえば、トランザクションが日付順に並んでいる場合、黒いドットのパターンから、
購入される商品の数や種類に対する季節的な影響があきらかになることがある。
おそらくクリスマスやハヌカー（ユダヤ教の祭り）の時期はおもちゃの購入が増え、ハロウィンの時期はお菓子の購入が増えるはずだ。
この種の可視化が特に役立つのは、商品がさらにカテゴリ別にソートされている場合である。
しかし、ほとんどの場合、プロットはテレビ画面の砂嵐さながらにランダムなものに見えるだろう。\
　このような可視化は、極めて大規模なトランザクションでーたべーすではそれほど効果的でないことを覚えておこう。
というのも、セルが小さくなりすぎて見分けがつかなくなるからだ。
それでも、sample関数と組み合わせれば、疎行列のトランザクションをランダムに抽出したうえで可視化できる。
100件のトランザうションをランダムに抽出するコマンドは次のようになる。

```{r}
image(sample(groceries, 100))
```

　ドットが集中しているように見える列は、店舗において非常に人気の高い商品を表している。
しかし、全体的には、ドットの分布はかなりランダムに見える。
他に注意すべき点はないものとして、分析を続ける。

### ステップ３：モデルを訓練する

　データの準備ができたところで、買い物かごに入っている商品の間で相関を見つけ出す作業に取り掛かる。
ここでは、groceriesデータの調査と前処理に使ったarulesパッケージのアプリオリアルゴリズムの実装を行うことにする。\
　apriori関数を実行するのは簡単だが、相関ルールを妥当な数にするには、supportパラメータとconfidenceパラメータの適切な値を見つけ出すために
試行錯誤の繰り返しが必要なることがある。
ハードルを上げすぎると、ルールが一つも見つからないどころか、一般的すぎて役に立たないルールが見つかるかもしれない。
逆に、ハードルが低すぎると、生成されるルールの数が多すぎて手に負えなくなるかもしれない。
それだけならまだしも、処理がいつまでも終わらなかったり、学習中にメモリを使い果たしてしまったりすることも考えられる。\
　groceriesデータでは、デフォルトtのsuppport = 0.1 と confidence = 0.8
を使った場合、ルールは１つも見つからない。

```{r}
apriori(groceries)
```

　どうやら、検索範囲を広げる必要があるようだ。

> 考えてみれば、この結果はそれほど意外なことではないはずだ。
> デフォルト値は support =
> 0.1なので、ルールを生成するには、商品が少なくとも 0.1 \* 9385 = 938.5
> 件のトランザクションに出現していなければならない。
> この頻度で出現する商品は８つしかないため、ルールが見つからなくても不思議ではない。

　支持度の最小値の設定という問題に対するアプローチの１つは、該当するトランザクションが何件あればそのパターンを興味深いとみなせるかについて考えてみることである。たとえば、商品が１日に２回購入されたら（一月に換算すると60回）、そのパターンを重要であると見なすとしよう。そのようにして、少なくともそれだけの数のトランザクションと合致するルールだけが見つかるようにして支持度を計算してくことができる。たとえば、9,825件のうちの60件は0.6%(0.006)であるため、最初の支持度をそのように設定してみればよい。\
　確信度の最小値の設定は、微妙なバランスを取ることが求められる。確信度が低すぎれば、信頼性の低いルールが大量に生成されることになるかもしれない。たとえば、電池はいろいろな商品と一緒に購入される傾向にあるため、電池と一緒に購入される商品を示すルールがいくつも生成されるかもしれない。これでは、広告予算をどこに振り分ければよいかはわからない。一方で、確信度が高すぎれば、ルールは「火災報知器は常に電池と一緒に購入される」といった自明なものか必然的なものばかりになってしまうだろう。たとえば、火災報知器はほぼ必ずと言ってよいほど電池と一緒に購入されるため、火災報知器を電池の近くに陳列しても、売上に貢献することはないだろう。

> 確信度の適切な最小値は分析の目標に大きく依存する。保守的な値から始めて、意思決定に活かせる知識が見つからない場合は、いつでもハードルを下げて検索範囲を広げることができる。

　確信度の最小値（閾値）を最初は0.25に設定するとしよう。つまり、ルールが結果に含まれるためには、25%以上の割合で正しくなければならない。このようにすると、最も信頼性の低いルールが除外される一方、ターゲティング広告のやり方を変更する余裕もできる。\
　これで、ルールを生成する準備が整った。supportパラメータとconfidenceパラメータの最小値に加えて、商品を１つしか含んでいないルールを除外するために
minlen = 2 を指定するとよいだろう。このようにすると、たとえば {} =\>
whole milk
のように、商品が頻繁に購入されているという理由だけで重要ではないルールが生成されるのを阻止できる。whole
milk はトランザクションの 25%
以上で購入されているため、支持度と確信度の最小値を満たしているが、意思決定に大きく役立つ知見ではない。\
　アプリオリアルゴリズムを使って相関ルールを見つけ出すためのコマンド全体は次のようになる。

```{r}
groceryrules <- apriori(
    groceries, 
    parameter = list(support = 0.006, confidence = 0.25, minlen = 2)
    )
```

```{r}
groceryrules
```

　groceryrulesオブジェクトは463個の相関ルールを含んでいる。その中に有益なものが含まれているかどうかを判断するには、少し詳しく調べる必要がある。

### ステップ４：モデルの性能を評価する

　相関ルールを高い視点から捉えたいばあいは、summary関数を使うことができる。ルールの長さの分布(rule
length
distribution)は、アイテムの数が２、３、４個のルールがそれぞれいくつ買ったかを示している。このルールセットでは、アイテムの数が２つのルールが150個、アイテムの数が３つのルールが297個、アイテムの数が４つのルールが16個である。出力には、この分布の要約統計量も含まれている。

```{r}
summary(groceryrules)
```

> この出力にも示されているように、ルールの長さは、ルールのLHSとRHSのアイテム数の合計として計算される。つまり、{bread}
> =\> {butter} のようなルールのアイテム数は２、{peanut butter, jelly}
> =\> {bread} のようなルールのアイテム数は３である。

　続いて、ルールの品質を示す要約統計量であるsupport、confidence、liftが表示されている。supportとconfidenceはルールの選択基準として使われているため、それほど意外な値ではない。ルールのほとんどまたはすべてのsupportとconfidenceの値が最小値（閾値）に非常に近い場合は、ハードルを高く設定しすぎたのかもしれないので、要注意である。この場合は、どちらの値もかなり大きいルールがいくつもあるため、その心配はない。

　４つ目の列は、まだ検討したことのない指標である。ルールの**リフト**(lift)は、一方のアイテムまたはアイテムセットが購入されていることがわかっている場合に、一般的な購入率を基準として、もう一方のアイテムまたはアイテムセットが購入される確率がどれくらい高くなるかを表す。式として定義すると、次のようになる。

$$
{\rm lift}(X \to Y)=\frac{{\rm confidence}(X \to Y)}{{\rm support}(Y)}
$$

> アイテムの順序が意味を持つ確信度とは異なり、$lift(X \to Y)$
> は$lift(Y \to X)$と同じである。

　たとえば、食料品店では、ほとんどの人がmilkとbreadを購入するとしよう。たまたま、milkとbreadを両方とも含んだトランザクションがいくつも見つかるというのは十分に想像できる。しかし、$lift(milk \to bread)$が1よりも大きいとしたら、これら２つの商品が一緒に見つかる確率は単なる偶然よりも高いということになる。したがって、リフトの値が大きいことは、そのルールが重要で、アイテム感に真のつながりがあることを反映している。\
　summary関数の出力の最後の部分には、これらのルールをどのようにして選択したのかに関するマイニング情報が含まれている。9,835件のトランザクションを含んでいるgroceriesデータを使って、これらのルールを支持度の最小値0.06、確信度の最小値0.25で作成したことがわかる。

　特定のルールの内容はinspect関数を使って調べることができる。例として、groceryrulesオブジェクトの最初の３つのルールを調べてみよう。

```{r}
inspect(groceryrules[1:3])
```

　出力の見方（最初のルールの例）

-   [lhs, rhs] potted plants を購入した顧客は whole milk も購入する

-   [support, confidence] 支持度0.007、確信度0.400
    ：このルールはトランザクションの0.7%をカバーしており、potted plants
    が購入されたときの40%にルールが当てはまる

-   [lift] リフトの値は、平均的な顧客と比較して、観客が potted plants
    を購入したら whole milk
    も購入する確率がどれくらい高くなるかを示している。顧客の25.6%が
    whole milk を購入したことがわかっているため(support)、potted plants
    を購入した顧客の40%が whole milk
    を購入するとしたら(confidence)、リフトは0.40/0.256=1.56
    であり、表示されている値と一致する。これは、potted plants
    を購入すると購入しなかった顧客に比べて whole milk
    を購入する確率が約1.6倍になることを意味している

　これは本当に有益なルールだろうか？\
　一般的なアプローチは、相関ルールを次の3つのカテゴリに分類することである。

-   Actionable
-   Trivial
-   Inexplicable

　バスケット分析の目標は、明確かつ有益な知見をもたらす**Actionable**ルールを見つけ出すことである。
明確なルールもあれば、有益なルールもあるが、両方の要素を併せ持つルールはそうそう見つからない。\
　**Trivial**ルールはあまりにも明白で、いまさら言うまでもないルールが含まれる。
たとえば、貴方がマーケティングコンサルタントで、クロスプロモーションの新しい機会を見つけることで
高い報酬を得ているとしよう。 紙オムツと粉ミルク
$(\{diapers\} \to \{formula\})$なんてどうでしょうと持ちかけたりすれば、次の依頼はないだろう。

> Trivialルールは、より興味具回結果の中に紛れ込んでいることがある。たとえば、
> 特定のブランドの子供向けシリアルと特定の映画のDVDの間で相関が見つかったとしよう。
> そのシリアルのパッケージにその映画の主人公が描かれているとしたら、
> それほど洞察力のある発見ではあるとは言えないだろう。

　**Indexplicable**ルールには、アイテム間の結びつきがあまり明白ではなく、
その情報をどのように利用すればよいかを突き止めるのが不可能であるか、不可能に近いルールが含まれる。
そのルールはデータに含まれているランダムなパターンにすぎないのかもしれない。
たとえば、$\{pickles\} \to  \{chocolate\ ice\ cream \}$というルールが作成されたのは、
顧客の妻が妊娠していて、奇妙な組み合わせの食べ物を日常的にほしがるようになったせいかもしれない。\
　最も有益なルールは隠された宝石であり、瞭然たる事実だったのに見つかるまで気づかなかった手がかりのようなものである。
十分な時間があれば、ルールを１つ１つ調べて宝石を見つけ出そうと思えばできないことはない。
しかし、ルールがActionable、Trivial、Inexplicableのどれであるかを判断するにあたって、データサイエンティストは必ずしも適任ではない。
したがって、より適切なルールを見つけ出すには、小売チェーンを担当していて、見つかったルールの解釈を手助けできる、
その道の専門家の協力を仰ぐ必要があるだろう。
次項では、そうした共有を容易にするために、学習したルールを並べて最も重要なルールが先頭に来るようにし、
その結果をエクスポートする手法を取り入れる。

### ステップ５：モデルの性能を向上させる

　その分野の専門家であれば、有益なルールをすぐに見つけ出せるかもしれない。
しかし、数百あるいは数千ものルールの評価を信頼すれば、彼らの時間を無駄にすることになる。
そこで、様々な基準に従ってルールを並び替え、マーケティングチームと共有して詳しく分析できる形式で
Rの外に取り出せるようになっていると便利である。
このようにして分析結果をよりActionableにすれば、ルールを向上させることができる。

#### 相関ルールをソートする

　バスケットの目的によりルールをソートすることができる。

```{r}
inspect(sort(groceryrules, by = 'lift')[1:5])
```

　先ほどの調べたルールよりも、こちらのルールのほうが興味深いものに見える。
１つ目のルールのリフトは約3.96であり、ハーブ(herbs)を購入する人が根菜(root
vegetablels)も購入する確率が
一般的な顧客の約４倍であることを示している。
多分シチューを作るのだろう。
２つ目のルールの興味深いもので、ベリー類(berries)を購入する人がホイップクリーム(whipped/sour
cream)も購入する確率が３倍デあることを 示している。
ベリーとホイップといえばデザートだろう。

#### 相関ルールのサブセットを取得する

　キャンペーンを決定する前に、ベリー類とよく一緒に購入されている他の商品があるかどうかを調べるように依頼された。
この問いに答えるには、何らかの形でベリー類が含まれているルールをすべて洗い出す必要がある。\
　subset関数は、トランザクション、アイテム、またはルールのサブセットを検索する手段を提供する。
berriesが含まれているルールをすべて検索するコマンドは以下の通り。

```{r}
berryrules <- subset(groceryrules, items %in% 'berries')
inspect(berryrules)
```

　berriesが含まれているルールが４つあり、そのうちの２つはActionableに分類して良さそうに思える。
ベリー類は、ホイップクリームの他にも、よくヨーグルトといっしょに購入されtる。
朝食や昼食はもちろん、デザートにも良さそうな組み合わせだ。\
　subset関数は非常に強力であり、サブセットを選択するための基準を複数のキーワードや演算子を使って定義できる。

-   ここで使ったitemキーワードは、ルールの何処かに含まれているアイテムをマッチングする。
    マッチングをLHSまたはRHSに制限したい場合は、代わりにlhsまたはrhsを使う。
-   %in%演算子は、アイテムの少なくとも１つがサブセットに含まれていなければならないことを意味する。
    berriesまたはyogurtのどちらかを武勲でいるルールが必要な場合は、items
    %in% c('berries', 'yogurt') と指定する。
-   部分マッチングを行う演算子(%pin%)と完全マッチングを行う演算子(%ain%)も利用できる。
    部分マッチングでは、citrus fruit と tropical fruit の両方を items
    %pin% 'fruit' で一度に検索できる。
    完全マッチングでは、指定されたアイテムがすべて含まれていることが求められる。
    たとえば、items %ain% c('berries', 'yogurt') は berries と yogurt
    を両方含んでいるルールだけを検索する。
-   サブセットもsupport、confidence、liftで絞り込むことができる。たとえば、
    confidece \> 0.50 はルールを確信度が50％を超えるものだけに制限する。
-   マッチング条件は、AND(&)、OR(\|)、NOT(!)などのRの標準的な論理演算子を使って
    組み合わせることができる

#### 相関ルールをファイルまたはデータフレームに保存する

　バスケット分析の結果を共有したい場合は、write関数を使ってるpるをCSVファイルに
保存できる。

```{r}

write(
    groceryrules, 
    file = file.path(tempdir(),'groceryrules.csv'), 
    sep = ',', 
    quote = TRUE, 
    row.names = FALSE
)

```

　ルールをRのデータフレームに変換できると便利なこともある。
このコマンドを実行すると、因子フォーマットのルールと、支持度、確信度、リフトが数値ベクトルとして含まれたデータフレームが作成される。

```{r}
groceryrules_df <- as(groceryrules, 'data.frame', )

str(groceryrules_df)
```

　ルールをさらに処理したい場合や、別のデータベースにエクスポートしたい場合は、ルールを
データフレームに保存する方法が役に立つだろう。

## 8.3 まとめ

　相関ルールは大規模な小売店の大規模なトランザクションデータベースから有益な手がかり
を見つけ出すために使われる。教師なし学習プロセスである相関ルール学習器は、どのような
パターンを探しているのかに関する知識をあらかじめ与えなくても、大規模なデータベースか
ら知識を抽出できる。難点は、大量の情報を小さく管理しやすい結果セットに絞り込むために、
それなりの作業が発生することである。本章で取り上げたアプリオリアルゴリズムは、興味度
の最小値（閾値）を設定し、それらの基準を満たす相関だけを報告することで情報を絞り込む。
　ここでは、中規模のスーパーマーケットで記録されたひと月のトランザクションでバス
ケット分析を行いながら、アプリオリアルゴリズムを実際に試してみた。このような単純な例
でも、相関が山ほど見つかった。そして、将来の販促キャンペーンで役立ちそうなパターンに
注目した。ここで適用した手法は、より大規模な小売店の何倍もの大きさのデータベースでも
使われており、小売業以外のプロジェクトにも応用できる。
　次章では、少子なし学習アルゴリズムをもう１つ取り上げる。データの中からパターンを見
つけだすという点では相関ルールに似ている。しかし、関連するアイテムや特徴量のグループ
を検索する相関ルールとは異なり、次章の手法はインスタンス間の関係を探ることに関連して
いる。
